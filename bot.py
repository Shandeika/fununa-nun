import asyncio
import datetime
import io
import logging
import os
import re
import socket
import subprocess
import time
import traceback
from concurrent.futures import ThreadPoolExecutor

import aiohttp
import discord
import psutil as psutil
from discord import app_commands
from discord.ext import commands
from dotenv import load_dotenv
from gtts import gTTS

from basic_commands import BasicCommands
from dalle import DALLE
from gpt import GPT
from music import Music
from responder import Responder

logger = logging.getLogger("bot")
logger.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s "%(funcName)s" [%(levelname)s]: %(message)s', datefmt='%d.%m.%Y-%H:%M:%S')
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)
console_handler.setFormatter(formatter)
logger.addHandler(console_handler)

load_dotenv()

DISCORD_TOKEN = os.environ.get("DISCORD_TOKEN")

VERSION = "0.0.1"


class FununaNun(commands.Bot):
    def __init__(self, **options):
        intents = discord.Intents.all()
        super().__init__(
            command_prefix="!",
            intents=intents,
            # help_command=None,
            **options
        )
        self.owner_id = 335464992079872000
        self.__logger = logging.getLogger("bot")

    async def setup_hook(self) -> None:
        self.__logger.debug("Start loading modules")
        await self.add_cog(Music(bot))
        await self.add_cog(GPT(bot))
        await self.add_cog(BasicCommands(bot))
        await self.add_cog(Responder(bot))
        await self.add_cog(DALLE(bot))
        await self.tree.sync()
        self.__logger.debug("Setup hook completed")

    async def on_ready(self):
        logger.info(f'Logged in as "{self.user.name}" with ID {self.user.id}')
        activity = discord.CustomActivity(name="–°–ª—É—à–∞–µ–º –º—É–∑—ã–∫—É –≤–º–µ—Å—Ç–µ", emoji=discord.PartialEmoji(name="üéµ"))
        await bot.change_presence(status=discord.Status.idle, activity=activity)

    async def play_file(self, filename: str, voice: discord.VoiceClient):
        # –ø—Ä–æ–∏–≥—Ä–∞—Ç—å –∞—É–¥–∏–æ
        voice.play(discord.FFmpegPCMAudio(filename))
        # –æ–∂–∏–¥–∞—Ç—å –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø—Ä–æ–∏–≥—Ä—ã–≤–∞–Ω–∏—è
        while voice.is_playing():
            await asyncio.sleep(1)
        # –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø—Ä–æ–∏–≥—Ä—ã–≤–∞–Ω–∏–µ
        voice.stop()
        # –æ—Ç–∫–ª—é—á–∏—Ç—å—Å—è –æ—Ç –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ –∫–∞–Ω–∞–ª–∞
        return await voice.disconnect()

    async def gtts_get_file(self, text: str):
        executor = ThreadPoolExecutor()

        def gtts_generate():
            tts = gTTS(text=text, lang='ru')
            tts.save('sound.mp3')

        return await bot.loop.run_in_executor(executor, gtts_generate)


bot = FununaNun()


class TracebackShowButton(discord.ui.View):
    def __init__(self, traceback_text: str):
        super().__init__()
        self._tb = traceback_text

    @discord.ui.button(label="–ü–æ–∫–∞–∑–∞—Ç—å traceback", style=discord.ButtonStyle.red, emoji="üõ†")
    async def traceback_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if len(self._tb) >= 4096:
            embed = discord.Embed(title="Traceback",
                                  description="Traceback –ø—Ä–∏–∫—Ä–µ–ø–ª–µ–Ω –æ—Ç–¥–µ–ª—å–Ω—ã–º —Ñ–∞–π–ª–æ–º, —Ç–∞–∫ –∫–∞–∫ –æ–Ω —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π",
                                  color=discord.Color.red())
            tb_file = discord.File(io.BytesIO(self._tb.encode("utf-8")), filename="traceback.txt")
            return await interaction.response.send_message(embed=embed, file=tb_file, ephemeral=True)
        embed = discord.Embed(title="Traceback", description=f"```\n{self._tb}\n```", color=discord.Color.red())
        await interaction.response.send_message(embed=embed, ephemeral=True)


@bot.tree.error
async def app_commands_error_handler(interaction: discord.Interaction, error: app_commands.AppCommandError) -> None:
    if isinstance(error.original, discord.Forbidden):
        embed = discord.Embed(title="–û—à–∏–±–∫–∞", description="–ù–µ—Ç –ø—Ä–∞–≤ —Å–¥–µ–ª–∞—Ç—å —ç—Ç–æ", color=discord.Color.red())
    elif isinstance(error.original, aiohttp.ClientResponseError):
        embed = discord.Embed(title="–û—à–∏–±–∫–∞", description="–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∑–∞–ø—Ä–æ—Å–∞", color=discord.Color.red())
    else:
        embed = discord.Embed(title="–û—à–∏–±–∫–∞", description=f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞", color=discord.Color.red())
        embed.add_field(name="–¢–∏–ø –æ—à–∏–±–∫–∏", value=type(error.original))
        embed.add_field(name="–¢–µ–∫—Å—Ç –æ—à–∏–±–∫–∏", value=str(error.original))
        embed.add_field(name="–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –æ—à–∏–±–∫–µ", value=str(error))
    traceback_text = "".join(
        traceback.format_exception(type(error.original), error.original, error.original.__traceback__))
    try:
        await interaction.response.send_message(embed=embed, view=TracebackShowButton(traceback_text))
    except discord.InteractionResponded:
        await interaction.followup.send(embed=embed, view=TracebackShowButton(traceback_text))


@bot.tree.command(
    name="tts",
    description="–û–∑–≤—É—á–∏—Ç –≤–≤–µ–¥–µ–Ω–Ω—É—é —Ñ—Ä–∞–∑—É –≤ –≥–æ–ª–æ—Å–æ–≤–æ–º –∫–∞–Ω–∞–ª–µ"
)
@app_commands.rename(
    text="—Ç–µ–∫—Å—Ç"
)
@app_commands.describe(
    text="–¢–µ–∫—Å—Ç, –∫–æ—Ç–æ—Ä—ã–π –Ω—É–∂–Ω–æ –æ–∑–≤—É—á–∏—Ç—å"
)
async def _tts(interaction: discord.Interaction, text: str):
    if interaction.user.voice is None:
        embed = discord.Embed(title="–û—à–∏–±–∫–∞", description="–¢—ã –Ω–µ –≤ –∫–∞–Ω–∞–ª–µ", color=discord.Color.red())
        await interaction.response.send_message(embed=embed)
        return
    await interaction.response.defer(ephemeral=False, thinking=True)

    await bot.gtts_get_file(text)

    # –ø–æ–¥–∫–ª—é—á–∞–µ–º –±–æ—Ç–∞ –∫ –∫–∞–Ω–∞–ª—É
    voice = await interaction.user.voice.channel.connect()

    # –ø—Ä–æ–∏–≥—Ä—ã–≤–∞–µ–º —Ñ–∞–π–ª
    await bot.play_file("sound.mp3", voice)

    embed = discord.Embed(title="TTS", description=text, color=discord.Color.blurple())
    await interaction.followup.send(embed=embed)

    return


@bot.tree.command(
    name="status",
    description="–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å—Ç–∞—Ç—É—Å –±–æ—Ç–∞"
)
async def _status(interaction: discord.Interaction):
    def process_time(seconds):
        days = seconds // 86400
        seconds %= 86400
        hours = seconds // 3600
        seconds %= 3600
        minutes = seconds // 60
        result = ""
        if days > 0:
            result += f"{days} –¥–Ω–µ–π, "
        if hours > 0:
            result += f"{hours} —á–∞—Å–æ–≤, "
        if minutes > 0:
            result += f"{minutes} –º–∏–Ω—É—Ç"
        return result.strip(", ")

    server_hostname = socket.gethostname()
    discord_gateway = bot.ws.latency * 1000
    ram_free = psutil.virtual_memory()[3] / 1024 / 1024
    ram_total = psutil.virtual_memory()[0] / 1024 / 1024
    ram_used = ram_total - ram_free
    cpu_usage = psutil.cpu_percent()
    la_1, la_5, la_15 = psutil.getloadavg()

    server_uptime = process_time(int(time.time() - psutil.boot_time()))

    # –ó–∞–ø—É—Å—Ç–∏—Ç—å –∫–æ–º–∞–Ω–¥—É systemctl status fn.service –∏ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –µ–µ –≤—ã–≤–æ–¥ –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π output
    output = subprocess.check_output(['systemctl', 'status', 'fn.service'], universal_newlines=True)

    # –ù–∞–π—Ç–∏ —Å—Ç—Ä–æ–∫—É "Active:" –≤ –≤—ã–≤–æ–¥–µ –∏ –ø–æ–ª—É—á–∏—Ç—å –µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
    match = re.search(r'Active:\s+(.*?)\n', output)
    active_value = match.group(1)

    # –ù–∞–π—Ç–∏ —Å—Ç—Ä–æ–∫—É "since" –≤ –∑–Ω–∞—á–µ–Ω–∏–∏ Active –∏ –ø–æ–ª—É—á–∏—Ç—å –µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
    match = re.search(r'since\s+(.*)', active_value)
    bot_uptime_dt = datetime.datetime.strptime(match.group(1).split(";")[0], '%a %Y-%m-%d %H:%M:%S %Z')
    bot_uptime = process_time(int(time.time() - bot_uptime_dt.timestamp()))

    embed_description = f"–í–µ—Ä—Å–∏—è: `{VERSION}`\n" \
                        f"–ü–∏–Ω–≥ —à–ª—é–∑–∞ Discord `{discord_gateway:.2f} –º—Å`\n" \
                        f"–í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã –±–æ—Ç–∞ **{bot_uptime}**"
    server_label = f"–°–µ—Ä–≤–µ—Ä: `{server_hostname}`\n" \
                   f"LA1 `{la_1:.2f}`, LA5 `{la_5:.2f}`, LA15 `{la_15:.2f}`\n" \
                   f"–ó–∞–≥—Ä—É–∑–∫–∞ CPU `{cpu_usage:.2f}%`\n" \
                   f"–ó–∞–≥—Ä—É–∑–∫–∞ RAM `{ram_used:.2f} –ú–ë` –∏–∑ `{ram_total:.2f} –ú–ë`\n" \
                   f"–°–≤–æ–±–æ–¥–Ω–∞—è RAM `{ram_free:.2f} –ú–ë`\n" \
                   f"–í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã **{server_uptime}**"

    embed = discord.Embed(title="–°—Ç–∞—Ç—É—Å –±–æ—Ç–∞", description=embed_description, color=discord.Color.blurple())
    embed.add_field(name="–°–µ—Ä–≤–µ—Ä", value=server_label, inline=False)
    await interaction.response.send_message(embed=embed)


bot.run(DISCORD_TOKEN)
